// --- File: src/app/api/v1/dpp/verify/[productId]/route.ts ---
// Description: Conceptual API endpoint to simulate verification of a DPP by Product ID from path.

import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";
import { MOCK_DPPS } from "@/data";
import { validateApiKey } from "@/middleware/apiKeyAuth";

// Request body is currently not used for this endpoint as productId comes from path.
// interface VerifyDppRequestBody {
//   // Potentially other verification parameters in the future
// }

interface VerificationResponse {
  productId: string;
  verificationStatus:
    | "Verified"
    | "VerificationFailed"
    | "PendingFurtherChecks"
    | "ProductNotFound";
  message: string;
  timestamp: string;
  checksPerformed?: string[];
}

export async function POST(
  request: NextRequest,
  { params }: { params: { productId: string } },
) {
  const productId = params.productId;

  if (!productId || typeof productId !== "string" || productId.trim() === "") {
    return NextResponse.json(
      {
        error: {
          code: 400,
          message:
            "Path parameter 'productId' is required and must be a non-empty string.",
        },
      },
      { status: 400 },
    );
  }

  const auth = validateApiKey(request);
  if (auth) return auth;

  // Conceptual API key authentication - skipped for mock
  // const authHeader = request.headers.get('Authorization');
  // if (!authHeader || !authHeader.startsWith('Bearer ')) {
  //   return NextResponse.json({ error: { code: 401, message: 'API key missing or invalid.' } }, { status: 401 });
  // }

  const product = MOCK_DPPS.find((dpp) => dpp.id === productId);

  // Simulate API delay and verification process
  await new Promise((resolve) => setTimeout(resolve, 300));
  const now = new Date().toISOString();

  if (!product) {
    return NextResponse.json(
      {
        productId: productId,
        verificationStatus: "ProductNotFound",
        message: `Product with ID ${productId} not found for verification.`,
        timestamp: now,
      } as VerificationResponse,
      { status: 404 },
    );
  }

  // Simulate different verification outcomes
  const outcomes: VerificationResponse["verificationStatus"][] = [
    "Verified",
    "VerificationFailed",
    "PendingFurtherChecks",
  ];
  const randomOutcome = outcomes[Math.floor(Math.random() * outcomes.length)];

  let message = "";
  const checksPerformed = [
    "Mock Data Integrity Check (Simulated)",
    "Mock EBSI Anchor Verification (Simulated)",
    "Mock Critical Compliance Field Check (Simulated)",
  ];

  switch (randomOutcome) {
    case "Verified":
      message = `Product DPP for ID ${productId} integrity and key compliance points (mock) verified successfully.`;
      // Conceptually update the product's EBSI status if verified
      // MOCK_DPPS.find(p => p.id === productId)!.ebsiVerification = { status: 'verified', lastChecked: now, verificationId: `ebsi_mock_vrf_${Date.now()}` };
      break;
    case "VerificationFailed":
      message = `Verification for product DPP ID ${productId} failed. Discrepancies found in mock compliance data.`;
      // MOCK_DPPS.find(p => p.id === productId)!.ebsiVerification = { status: 'not_verified', lastChecked: now, message: "Mock verification failed" };
      break;
    case "PendingFurtherChecks":
      message = `Initial verification for product DPP ID ${productId} passed, but further checks are pending.`;
      // MOCK_DPPS.find(p => p.id === productId)!.ebsiVerification = { status: 'pending_verification', lastChecked: now, message: "Awaiting secondary checks" };
      break;
  }

  const responsePayload: VerificationResponse = {
    productId: productId,
    verificationStatus: randomOutcome,
    message: message,
    timestamp: now,
    checksPerformed: checksPerformed,
  };

  return NextResponse.json(responsePayload);
}
